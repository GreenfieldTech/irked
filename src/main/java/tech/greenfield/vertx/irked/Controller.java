package tech.greenfield.vertx.irked;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import io.vertx.core.Handler;
import io.vertx.ext.web.RoutingContext;
import tech.greenfield.vertx.irked.exceptions.InvalidRouteConfiguration;
import tech.greenfield.vertx.irked.websocket.WebSocketMessage;

/**
 * Irked Controller Base Class
 * 
 * This class is at the heart of the Irked request routing logic. To expose your APIs through
 * Irked, extends this class and define your routes as fields and methods of the {@code Controller}
 * child class. You may also want to take advantage of {@code RoutingContext} ({@code Request})
 * reprogramming logic by overriding the {@link #getRequestContext(Request)} method.
 * Then you can either mount your controller directly into an Irked router using {@link Router#with(Controller, String)},
 * or - better yet - create a hierarchy of Controllers by creating a top-level {@code Controller}
 * implementation that mounts sub-cotrollers using {@code Controller} fields, and just mount
 * the top level controller using {@link Router#with(Controller)}.
 */
public class Controller {

	/**
	 * Helper interface to make it easier to define simple route
	 * handlers that use the Irked {@link Request} API.
	 * 
	 * Example:
	 * <pre>{@code
	 * @Get("/example")
	 * WebHandler exampleHandler = r -> r.send("Hello World");
	 * }</pre>
	 */
	protected interface WebHandler extends Handler<Request> {}

	/**
	 * Helper interface to make it easier to define simple WebSocket
	 * message handlers that use the Irked {@link WebSocketMessage} API.
	 * 
	 * Example:
	 * <pre>{@code
	 * @WebSocket("/socket")
	 * MessageHandler handler = m -> m.reply("Hello World");
	 * }</pre>
	 */
	protected interface MessageHandler extends Handler<WebSocketMessage> {}

	/**
	 * Helper interface to make it easier to define simple route
	 * handlers that use the Vert.x {@link RoutingContext} API.
	 * 
	 * Example:
	 * <pre>{@code
	 * @Get("/example")
	 * RawVertxHandler exampleHandler = r -> r.response().end("Hello World");
	 * }</pre>
	 */
	protected interface RawVertxHandler extends Handler<RoutingContext> {}

	private List<RouteConfiguration> routes;
	
	/**
	 * Controller implementations should override this to generate local
	 * request implementation (wrapped routing contexts).
	 * 
	 * The default implementation just returns the passes request wrapper
	 * @param request Top level request wrapper generated by Irked
	 * @return Implementation of a sub-context request
	 */
	protected Request getRequestContext(Request request) {
		return request;
	}
	
	/**
	 * Helper method for {@link Router} to discover routing endpoints
	 * @return list of fields that are routing endpoints
	 * @throws InvalidRouteConfiguration If one of the declared and annotated routes is invalid
	 */
	List<RouteConfiguration> getRoutes(Router router) throws InvalidRouteConfiguration {
		ArrayList<RouteConfiguration> out = new ArrayList<>();
		for (Field f : getClass().getDeclaredFields())
			out.add(RouteConfiguration.wrap(this, router, f));
		for (Method m : getClass().getDeclaredMethods())
			out.add(RouteConfiguration.wrap(this, router, m));
		return routes = out.stream().filter(RouteConfiguration::isValid).collect(Collectors.toList());
	}

	/**
	 * Helper method for {@link Router} to create the appropriate request
	 * handler for Vert.X
	 * @param field routing endpoint handler exposed by this controller
	 * @return a handler that takes a Vert.x original routing context and
	 *  wraps it in a local request context before delegating to the routing endpoint
	 */
	@SuppressWarnings("unchecked")
	Handler<RoutingContext> getHandler(Field field) {
		try {
			field.setAccessible(true);
			if (Handler.class.isAssignableFrom(field.getType()))
				return (Handler<RoutingContext>)field.get(this);
			return null;
		} catch (IllegalArgumentException | IllegalAccessException e) {
			// shouldn't happen
			throw new RuntimeException("Error accessing field " + field + ": " + e, e);
		}
	}

	/**
	 * Helper method for {@link Router} to mount sub-controllers
	 * @param field routing endpoint exposed by this controller
	 * @return Controller instance if the routing endpoint is a sub-controller,
	 * null otherwise 
	 */
	Controller getController(Field field) {
		try {
			field.setAccessible(true);
			if (Controller.class.isAssignableFrom(field.getType()))
				return (Controller)field.get(this);
			return null;
		} catch (IllegalArgumentException | IllegalAccessException e) {
			// shouldn't happen
			throw new RuntimeException("Error accessing field " + field + ": " + e, e);
		}
	}
	
	void remove() {
		routes.forEach(RouteConfiguration::remove);
	}
	
	@Override
	public String toString() {
		return getClass().getSimpleName();
	}
}
